/*
 * lcd.c
 *
 *  Created on: Oct 16, 2025
 *      Author: KOPPOLU MOUNIKA
 */


#include "lcd.h"
#include <string.h>

/* LCD pin variables */
static GPIO_TypeDef *LCD_RS_PORT, *LCD_EN_PORT;
static GPIO_TypeDef *LCD_D4_PORT, *LCD_D5_PORT, *LCD_D6_PORT, *LCD_D7_PORT;
static uint16_t LCD_RS_PIN, LCD_EN_PIN;
static uint16_t LCD_D4_PIN, LCD_D5_PIN, LCD_D6_PIN, LCD_D7_PIN;

/* Simple delay function */
static void delay_ms(uint32_t ms)
{
    for(uint32_t i=0; i<ms*8000; i++) __asm__("nop");
}

static void pulse_enable(void)
{
    LCD_EN_PORT->ODR |= LCD_EN_PIN;
    delay_ms(1);
    LCD_EN_PORT->ODR &= ~LCD_EN_PIN;
    delay_ms(1);
}

static void send_nibble(uint8_t nibble)
{
    if(nibble & 0x01) LCD_D4_PORT->ODR |= LCD_D4_PIN; else LCD_D4_PORT->ODR &= ~LCD_D4_PIN;
    if(nibble & 0x02) LCD_D5_PORT->ODR |= LCD_D5_PIN; else LCD_D5_PORT->ODR &= ~LCD_D5_PIN;
    if(nibble & 0x04) LCD_D6_PORT->ODR |= LCD_D6_PIN; else LCD_D6_PORT->ODR &= ~LCD_D6_PIN;
    if(nibble & 0x08) LCD_D7_PORT->ODR |= LCD_D7_PIN; else LCD_D7_PORT->ODR &= ~LCD_D7_PIN;
    pulse_enable();
}

static void send_byte(uint8_t data, uint8_t rs)
{
    if(rs) LCD_RS_PORT->ODR |= LCD_RS_PIN; else LCD_RS_PORT->ODR &= ~LCD_RS_PIN;
    send_nibble(data >> 4);
    send_nibble(data & 0x0F);
}

static void lcd_command(uint8_t cmd)
{
    send_byte(cmd, 0);
    delay_ms(2);
}

void LCD_Init(GPIO_TypeDef* rs_port, uint16_t rs_pin,
              GPIO_TypeDef* en_port, uint16_t en_pin,
              GPIO_TypeDef* d4_port, uint16_t d4_pin,
              GPIO_TypeDef* d5_port, uint16_t d5_pin,
              GPIO_TypeDef* d6_port, uint16_t d6_pin,
              GPIO_TypeDef* d7_port, uint16_t d7_pin)
{
    /* Save pins */
    LCD_RS_PORT = rs_port; LCD_RS_PIN = rs_pin;
    LCD_EN_PORT = en_port; LCD_EN_PIN = en_pin;
    LCD_D4_PORT = d4_port; LCD_D4_PIN = d4_pin;
    LCD_D5_PORT = d5_port; LCD_D5_PIN = d5_pin;
    LCD_D6_PORT = d6_port; LCD_D6_PIN = d6_pin;
    LCD_D7_PORT = d7_port; LCD_D7_PIN = d7_pin;

    /* Enable GPIO clocks */
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN;

    /* Configure pins as output */
    rs_port->MODER |= (1 << (2 * __builtin_ctz(rs_pin)));
    en_port->MODER |= (1 << (2 * __builtin_ctz(en_pin)));
    d4_port->MODER |= (1 << (2 * __builtin_ctz(d4_pin)));
    d5_port->MODER |= (1 << (2 * __builtin_ctz(d5_pin)));
    d6_port->MODER |= (1 << (2 * __builtin_ctz(d6_pin)));
    d7_port->MODER |= (1 << (2 * __builtin_ctz(d7_pin)));

    delay_ms(50);

    /* Initialization sequence */
    send_nibble(0x03); delay_ms(5);
    send_nibble(0x03); delay_ms(5);
    send_nibble(0x03); delay_ms(1);
    send_nibble(0x02); // 4-bit mode

    lcd_command(0x28); // 2 lines, 5x8 font
    lcd_command(0x0C); // Display ON, cursor OFF
    lcd_command(0x06); // Entry mode
    LCD_Clear();
}

void LCD_Clear(void) { lcd_command(0x01); delay_ms(2); }

void LCD_SetCursor(uint8_t row, uint8_t col)
{
    uint8_t addr = (row == 0) ? 0x00 : 0x40;
    addr += col;
    lcd_command(0x80 | addr);
}

void LCD_Print(char *str)
{
    for(uint16_t i = 0; i < strlen(str); i++)
        send_byte(str[i], 1);
}
