/*
 * lcd.c
 *
 *  Created on: Oct 16, 2025
 *      Author: KOPPOLU MOUNIKA
 */


#include "lcd.h"
#include "stm32l476xx.h"
#include <string.h>

static void LCD_PulseEnable(void)
{
    GPIOA->ODR |= LCD_EN_PIN;
    for(volatile int i=0;i<1000;i++); // small delay
    GPIOA->ODR &= ~LCD_EN_PIN;
    for(volatile int i=0;i<1000;i++);
}

static void LCD_SendNibble(uint8_t nibble)
{
    if(nibble & 0x01) GPIOB->ODR |= LCD_D4_PIN; else GPIOB->ODR &= ~LCD_D4_PIN;
    if(nibble & 0x02) GPIOB->ODR |= LCD_D5_PIN; else GPIOB->ODR &= ~LCD_D5_PIN;
    if(nibble & 0x04) GPIOB->ODR |= LCD_D6_PIN; else GPIOB->ODR &= ~LCD_D6_PIN;
    if(nibble & 0x08) GPIOB->ODR |= LCD_D7_PIN; else GPIOB->ODR &= ~LCD_D7_PIN;
    LCD_PulseEnable();
}

static void LCD_SendByte(uint8_t data, uint8_t rs)
{
    if(rs) GPIOA->ODR |= LCD_RS_PIN; else GPIOA->ODR &= ~LCD_RS_PIN;
    LCD_SendNibble(data >> 4);
    LCD_SendNibble(data & 0x0F);
}

static void LCD_Command(uint8_t cmd)
{
    LCD_SendByte(cmd, 0);
    for(volatile int i=0;i<5000;i++);
}

void LCD_Init(void)
{
    // Enable GPIO clocks
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN | RCC_AHB2ENR_GPIOBEN;

    // Configure pins as output
    GPIOA->MODER |= (1U<<16) | (1U<<18); // PA8, PA9
    GPIOB->MODER |= (1U<<0) | (1U<<2) | (1U<<4) | (1U<<6); // PB0-PB3

    for(volatile int i=0;i<100000;i++);

    // Init sequence
    LCD_SendNibble(0x03); for(volatile int i=0;i<5000;i++);
    LCD_SendNibble(0x03); for(volatile int i=0;i<5000;i++);
    LCD_SendNibble(0x03); for(volatile int i=0;i<5000;i++);
    LCD_SendNibble(0x02);

    LCD_Command(0x28); // 4-bit, 2 lines
    LCD_Command(0x0C); // Display ON
    LCD_Command(0x06); // Entry mode
    LCD_Clear();
}

void LCD_Clear(void)
{
    LCD_Command(0x01);
    for(volatile int i=0;i<5000;i++);
}

void LCD_SetCursor(uint8_t row, uint8_t col)
{
    uint8_t addr = (row == 0) ? 0x00 : 0x40;
    addr += col;
    LCD_Command(0x80 | addr);
}

void LCD_Print(char *str)
{
    for(uint16_t i=0;i<strlen(str);i++)
        LCD_SendByte(str[i],1);
}
